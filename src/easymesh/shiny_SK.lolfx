
[vert.glsl]
#version 120

attribute vec3 in_Position;
attribute vec3 in_Normal;
attribute vec4 in_Color;
attribute vec2 in_Index;
attribute vec2 in_Weight;

uniform mat4 in_ModelView;
uniform mat4 in_View;
uniform mat4 in_Proj;
uniform mat3 in_NormalMat;
//10is not a fix idea, should be more.
uniform mat4 in_BoneList[10];

varying vec4 pass_Vertex; /* View space */
varying vec3 pass_TNormal;
varying vec4 pass_Color;

void main(void)
{
    vec4 vertex = in_ModelView * vec4(in_Position, 1.0);
    vec3 tnorm = normalize(in_NormalMat * in_Normal);

    pass_Vertex = vertex;
    pass_TNormal = tnorm;
    pass_Color = in_Color;

    gl_Position = in_Proj * vertex;
}

[frag.glsl]
#version 120

#if defined GL_ES
precision highp float;
#endif

uniform float in_Damage;
uniform mat4 in_View;
uniform mat4 in_Inv_View;

uniform vec4 u_Lights[8 * 2];

varying vec4 pass_Vertex; /* View space */
varying vec3 pass_TNormal;
varying vec4 pass_Color;

#if 0
//Cube Light
//Cos(45) = 0.70710678118
//1.0 - Cos(45) = 0.29289321881

const float cos_45      = 0.70710678118;
const float inv_cos_45  = 0.29289321881;

vec4 in_Light3_Pos = vec4(-10.0, 20.0, 0.0, 1.0);
vec3 in_Light3_Size_Inner = vec3(12.0, 12.0, 12.0);
vec3 in_Light3_Size_Outer = vec3(10.0, 10.0, 10.0);
vec3 in_Light3_diffuse = vec3(0.4, 1.0, 0.4);
#endif

void main(void)
{
    /* Material properties */
    vec3 specular_reflect = vec3(0.8, 0.75, 0.4);
    float specular_power = 60.0;

    /* World properties */
    vec3 ambient = vec3(0.7, 0.7, 0.7);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    vec3 diffuse = vec3(0.0, 0.0, 0.0);

    /* Light precalculations */
    vec3 v = normalize(-pass_Vertex.xyz);

    /* Apply lighting */
    for (int i = 0; i < 8; i++)
    {
        vec4 pos = u_Lights[i * 2];
        vec4 color = u_Lights[i * 2 + 1];
        vec3 s, r;

        if (pos.w > 0.0)
        {
            /* Point light -- no attenuation yet */
            s = normalize((in_View * pos).xyz - pass_Vertex.xyz);
            r = reflect(-s, pass_TNormal);
        }
        else
        {
            /* Directional light */
            s = normalize(-pos.xyz);
            r = reflect(s, pass_TNormal);
        }

        float sdotn = max(dot(s, pass_TNormal), 0.0);
        diffuse += color.xyz * sdotn;
        if (sdotn > 0.0)
            specular += color.xyz * specular_reflect
                         * pow(max(dot(r, v), 0.0), specular_power);
    }

#if 0
    //Light calculation for cube light
    //const float cos_45      = 0.70710678118;
    //const float inv_cos_45  = 0.29289321881;
    vec3 local_vertex = (in_Inv_View * pass_Vertex).xyz - (in_Light3_Pos).xyz;
    vec3 proj_vertex = clamp(local_vertex.xyz, -in_Light3_Size_Inner, in_Light3_Size_Inner);
    vec3 proj_local_dir = local_vertex - proj_vertex;
    vec3 inner_dir = proj_vertex / in_Light3_Size_Inner;
    inner_dir.x = (inner_dir.x == 1.0)?(1.0):(0.0);
    inner_dir.y = (inner_dir.y == 1.0)?(1.0):(0.0);
    inner_dir.z = (inner_dir.z == 1.0)?(1.0):(0.0);

    //inside the cube
    if (length(proj_local_dir) == 0.0)
    {
        sdotn = 1.0;
        light_radius_mod = 1.0;
    }
    //spec calculation
    else
    {
        //Distance calculation
        vec3 proj_local_light = proj_local_dir / in_Light3_Size_Outer;
        light_radius_mod = max(0.0, 1.0 - length(proj_local_light));
        //cube orientation
        sdotn = max(0.0, dot(normalize(proj_local_dir), normalize(inner_dir)));


        //if (length(inner_dir) > 1.0)
        //    sdotn = 0.0;
        //else
        //{
        //    //vec3 proj_local_light = max(vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0) - abs(proj_local_dir / in_Light3_Size_Outer));
        //}
        /*
        proj_local_dir = normalize((in_View * vec4(proj_vertex + in_Light3_Pos.xyz,1.0)).xyz - pass_Vertex.xyz);
        sdotn = max(dot(proj_local_dir, pass_TNormal), 0.0);
        r = reflect(-proj_local_dir, pass_TNormal);
        if (sdotn > 0.0 && light_radius_mod > 0.0)
            specular += specular_color * min(specular_reflect, light_radius_mod)
                     * pow(max(dot(r, v), 0.0), specular_power);
        */
    }
    //diffuse calculation
    diffuse += in_Light3_diffuse * sdotn; //min(sdotn, light_radius_mod);
    //----------
#endif

    vec3 light = ambient + diffuse + specular;

    vec4 real_color = mix(pass_Color, vec4(1.2, 1.2, 1.2, 1.0), in_Damage);
    gl_FragColor = real_color * vec4(light, 1.0);
}

[vert.hlsl]

void main(float3 in_Vertex : POSITION,
          float3 in_Normal : NORMAL,
          float4 in_Color : COLOR,
          uniform float4x4 in_ModelView,
          uniform float4x4 in_Model,
          uniform float4x4 in_Proj,
          uniform float3x3 in_NormalMat,
          out float4 pass_Vertex : TEXCOORD0,
          out float3 pass_TNormal : TEXCOORD1,
          out float4 pass_Color : COLOR,
          out float4 out_Position : POSITION)
{
    float4 eye = mul(in_ModelView, float4(in_Vertex, 1.0));
    float3 tnorm = normalize(mul(in_NormalMat, in_Normal));

    pass_Vertex = eye;
    pass_TNormal = tnorm;
#ifdef _XBOX
    pass_Color = in_Color.abgr;
#else
    pass_Color = in_Color;
#endif

    out_Position = mul(in_Proj, eye);
}

[frag.hlsl]

void main(float4 pass_Vertex : TEXCOORD0,
          float3 pass_TNormal : TEXCOORD1,
          float4 pass_Color : COLOR,
          uniform float in_Damage,
          out float4 out_FragColor : COLOR)
{
    float3 in_LightDir = float3(0.3, 0.3, 0.7);

    /* Material properties */
    float3 specular_reflect = float3(0.8, 0.75, 0.4);
    float specular_power = 60.0;

    /* World properties */
    float ambient_mul = 0.5;
    float3 ambient_color = float3(0.25, 0.2, 0.35);
    float3 diffuse_color = float3(1.0, 1.0, 0.6);
    float3 specular_color = float3(1.0, 1.0, 0.6);

    float3 s = normalize(in_LightDir); /* normalize(pass_Vertex - lightpos); */
    float3 v = normalize(-pass_Vertex.xyz);
    float3 r = reflect(-s, pass_TNormal);

    float3 ambient = ambient_color;
    float sdotn = max(dot(s, pass_TNormal), 0.0);
    float3 diffuse = diffuse_color * sdotn;
    float3 specular = float3(0.0, 0.0, 0.0);
    if (sdotn > 0.0)
        specular = specular_color * specular_reflect
                 * pow(max(dot(r, v), 0.0), specular_power);
    float3 light = ambient + diffuse + specular;

    float4 real_color = in_Damage * float4(1.2, 1.2, 1.2, 1.0)
                      + (1.0 - in_Damage) * pass_Color;
    out_FragColor = real_color * float4(light, 1.0);
}

