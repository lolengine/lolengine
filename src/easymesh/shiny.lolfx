
[vert.glsl]
#version 120

attribute vec3 in_Vertex;
attribute vec3 in_Normal;
attribute vec4 in_Color;

uniform mat4 in_ModelView;
uniform mat4 in_View;
uniform mat4 in_Proj;
uniform mat3 in_NormalMat;

varying vec4 pass_Vertex; /* View space */
varying vec3 pass_TNormal;
varying vec4 pass_Color;

void main(void)
{
    vec4 vertex = in_ModelView * vec4(in_Vertex, 1.0);
    vec3 tnorm = normalize(in_NormalMat * in_Normal);

    pass_Vertex = vertex;
    pass_TNormal = tnorm;
    pass_Color = in_Color;

    gl_Position = in_Proj * vertex;
}

[frag.glsl]
#version 120

#if defined GL_ES
precision highp float;
#endif

uniform float in_Damage;
uniform mat4 in_View;
uniform mat4 in_Inv_View;

varying vec4 pass_Vertex; /* View space */
varying vec3 pass_TNormal;
varying vec4 pass_Color;

// FIXME: all the light parameters should be passed in the code
//Dir Light
vec3 in_LightDir = vec3(-0.3, -0.3, -0.7);

//Point Light
vec4 in_Light2_Pos = vec4(20.0, 10.0, 0.0, 1.0);
float in_Light2_Radius = 20.0;
vec3 in_Light2_diffuse = vec3(0.4, 0.4, 1.0);

//Cube Light
vec4 in_Light3_Pos = vec4(-10.0, 10.0, 5.0, 1.0);
vec3 in_Light3_Size_Inner = vec3(3.0, 1.0, 3.0);
vec3 in_Light3_Size_Outer = vec3(15.0, 15.0, 15.0);
vec3 in_Light3_diffuse = vec3(0.4, 1.0, 0.4);

void main(void)
{
    /* Material properties */
    vec3 specular_reflect = vec3(0.8, 0.75, 0.4);
    float specular_power = 60.0;

    /* World properties */
    float ambient_mul = 0.5;
    vec3 ambient_color = vec3(0.0, 0.0, 0.0);
    vec3 diffuse_color = vec3(0.4, 0.4, 0.4);
    vec3 specular_color = vec3(1.0, 1.0, 0.6);

    vec3 ambient = ambient_color;
    vec3 specular = vec3(0.0, 0.0, 0.0);
    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 s = vec3(0.0, 0.0, 0.0);
    vec3 v = vec3(0.0, 0.0, 0.0);
    vec3 r = vec3(0.0, 0.0, 0.0);
    float sdotn = 0.0;
	float light_radius_mod = 0.0;

    //Light calculation for directional light
    s = normalize(-in_LightDir);
    v = normalize(-pass_Vertex.xyz);
    r = reflect(s, pass_TNormal);

    sdotn = max(dot(s, pass_TNormal), 0.0);
    diffuse += diffuse_color * sdotn;
    if (sdotn > 0.0)
        specular += specular_color * specular_reflect
                 * pow(max(dot(r, v), 0.0), specular_power);
	//----------
    
    //Light calculation for point light
	vec3 tmpLightDir = (in_View * in_Light2_Pos).xyz - pass_Vertex.xyz;
	light_radius_mod = max(0.0, 1.0 - (length(tmpLightDir) / in_Light2_Radius));
    s = normalize(tmpLightDir);
    v = normalize(-pass_Vertex.xyz);
    r = reflect(-s, pass_TNormal);

    sdotn = max(dot(s, pass_TNormal), 0.0);
    diffuse += in_Light2_diffuse * min(sdotn, light_radius_mod);
    if (sdotn > 0.0 && light_radius_mod > 0.0)
        specular += specular_color * min(specular_reflect, light_radius_mod)
                 * pow(max(dot(r, v), 0.0), specular_power);
	//----------
    
    //Light calculation for cube light
	vec3 Local_Vertex = (in_Inv_View * pass_Vertex).xyz - (in_Light3_Pos).xyz;
	vec3 Proj_Vertex = clamp(Local_Vertex.xyz, -in_Light3_Size_Inner, in_Light3_Size_Inner);
	vec3 new_LightDir = Local_Vertex - Proj_Vertex;

	vec3 light_radius = max(vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0) - abs(new_LightDir / in_Light3_Size_Outer));
	light_radius_mod = min(light_radius.x, min(light_radius.y, light_radius.z));

	if (length(new_LightDir) == 0.0)
		sdotn = 1.0;
	else
	{
		new_LightDir = normalize((in_View * vec4(Proj_Vertex + in_Light3_Pos.xyz,1.0)).xyz - pass_Vertex.xyz);
		sdotn = max(dot(new_LightDir, pass_TNormal), 0.0);
	    r = reflect(-new_LightDir, pass_TNormal);
		if (sdotn > 0.0 && light_radius_mod > 0.0)
			specular += specular_color * min(specular_reflect, light_radius_mod)
					 * pow(max(dot(r, v), 0.0), specular_power);
	}
    diffuse += in_Light3_diffuse * min(sdotn, light_radius_mod);
	//----------

    vec3 light = ambient + diffuse + specular;

    vec4 real_color = in_Damage * vec4(1.2, 1.2, 1.2, 1.0)
                    + (1.0 - in_Damage) * pass_Color;
    gl_FragColor = real_color * vec4(light, 1.0);
}

[vert.hlsl]

void main(float3 in_Vertex : POSITION,
          float3 in_Normal : NORMAL,
          float4 in_Color : COLOR,
          uniform float4x4 in_ModelView,
          uniform float4x4 in_Model,
          uniform float4x4 in_Proj,
          uniform float3x3 in_NormalMat,
          out float4 pass_Vertex : TEXCOORD0,
          out float3 pass_TNormal : TEXCOORD1,
          out float4 pass_Color : COLOR,
          out float4 out_Position : POSITION)
{
    float4 eye = mul(in_ModelView, float4(in_Vertex, 1.0));
    float3 tnorm = normalize(mul(in_NormalMat, in_Normal));

    pass_Vertex = eye;
    pass_TNormal = tnorm;
#ifdef _XBOX
    pass_Color = in_Color.abgr;
#else
    pass_Color = in_Color;
#endif

    out_Position = mul(in_Proj, eye);
}

[frag.hlsl]

void main(float4 pass_Vertex : TEXCOORD0,
          float3 pass_TNormal : TEXCOORD1,
          float4 pass_Color : COLOR,
          uniform float in_Damage,
          out float4 out_FragColor : COLOR)
{
    float3 in_LightDir = float3(0.3, 0.3, 0.7);

    /* Material properties */
    float3 specular_reflect = float3(0.8, 0.75, 0.4);
    float specular_power = 60.0;

    /* World properties */
    float ambient_mul = 0.5;
    float3 ambient_color = float3(0.25, 0.2, 0.35);
    float3 diffuse_color = float3(1.0, 1.0, 0.6);
    float3 specular_color = float3(1.0, 1.0, 0.6);

    float3 s = normalize(in_LightDir); /* normalize(pass_Vertex - lightpos); */
    float3 v = normalize(-pass_Vertex.xyz);
    float3 r = reflect(-s, pass_TNormal);

    float3 ambient = ambient_color;
    float sdotn = max(dot(s, pass_TNormal), 0.0);
    float3 diffuse = diffuse_color * sdotn;
    float3 specular = float3(0.0, 0.0, 0.0);
    if (sdotn > 0.0)
        specular = specular_color * specular_reflect
                 * pow(max(dot(r, v), 0.0), specular_power);
    float3 light = ambient + diffuse + specular;

    float4 real_color = in_Damage * float4(1.2, 1.2, 1.2, 1.0)
                      + (1.0 - in_Damage) * pass_Color;
    out_FragColor = real_color * float4(light, 1.0);
}

